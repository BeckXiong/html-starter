<!DOCTYPE html>
<html>

<head>
    <title>Render Pixel Data</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p2.js/0.6.0/p2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>

<body>
    <div id="canvasContainer" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;"></div>

    <script>
        function deriveKey(password, salt) {
            return CryptoJS.PBKDF2(password, salt, {
                keySize: 256/32,
                iterations: 100000,
                hasher: CryptoJS.algo.SHA256
            });
        }

        function decryptData(encryptedData, salt, iv, password) {
            try {
                // Convert hex strings to CryptoJS format
                const saltWords = CryptoJS.enc.Hex.parse(salt);
                const ivWords = CryptoJS.enc.Hex.parse(iv);
                const encryptedWords = CryptoJS.enc.Hex.parse(encryptedData);
                
                // Derive key using the same parameters as server
                const key = deriveKey(password, saltWords);

                // Decrypt the data
                const decrypted = CryptoJS.AES.decrypt(
                    { ciphertext: encryptedWords },
                    key,
                    { iv: ivWords }
                );

                // Convert to string and parse JSON
                const decryptedStr = decrypted.toString(CryptoJS.enc.Utf8);
                return JSON.parse(decryptedStr);
            } catch (error) {
                console.error('Decryption error:', error);
                return null;
            }
        }
        // Function to render multiple pixels on canvas
        function renderPixelsToCanvas(pixels, ctx, offsetX, offsetY) {
            try {
            // Convert single pixel object to array if needed
            const pixelArray = Array.isArray(pixels) ? pixels : [pixels];
            
            pixelArray.forEach(pixel => {
                // Parse the color string to extract r, g, b values
                const [r, g, b] = pixel.color
                    .replace("rgb(", "")
                    .replace(")", "")
                    .split(",")
                    .map(Number);

                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(pixel.x + offsetX, pixel.y + offsetY, 1, 1);
            });
        } catch (error) {
            console.error('Error rendering pixels:', error);
        }
        }
        // Modified to handle multiple pixels in each SSE message
        function setupSSEConnection() {
            const canvas = createCanvas('live-canvas');
            const ctx = canvas.getContext("2d");

            // Set initial canvas size
            canvas.width = 600;
            canvas.height = 600;

            // Calculate the horizontal center (x position)
            const charWidth = 20;
            const charGap = 30;
            const numChars = 4;
            const totalTextWidth = (charWidth + charGap) * (numChars - 1) + charWidth;
            const startX = (canvas.width - totalTextWidth) / 2;

            // Calculate the vertical center (y position)
            const charHeight = 20;
            const startY = (canvas.height - charHeight) / 2;

            // Connect to SSE endpoint
            const evtSource = new EventSource('http://localhost:3000/api/bz4', {
                withCredentials: false
            });

            evtSource.onmessage = async (event) => {
                try {
                    const encryptedItems = JSON.parse(event.data);
                    const password = 'aaakuangbaokouhaiguaizhangge';

                    const jsonData = decryptData(encryptedItems.encrypted, encryptedItems.salt, encryptedItems.iv, password);
                    console.log(jsonData);
                    
                    let offsetX = startX;
                    let offsetY = startY;  // Use the calculated startY
                    jsonData.forEach(textItemSet => {
                        offsetX += charGap;
                        textItemSet.forEach(pixel => {
                            const x = pixel[Object.keys(pixel)[0]].charCodeAt(0);
                            const y = pixel[Object.keys(pixel)[1]].charCodeAt(0);
                            const color = pixel[Object.keys(pixel)[2]];
                            console.log(x, y, color);
                            renderPixelsToCanvas({ x, y, color }, ctx, offsetX, offsetY);
                        })
                    })
                } catch (error) {
                    console.error('Error processing SSE message:', error);
                }
            };

            evtSource.onerror = (error) => {
                console.error('SSE connection error:', error);
                evtSource.close();
            };
        }

        // Initialize single SSE connection
        setupSSEConnection();

        // Function to create a new canvas
        function createCanvas(filename) {
            const container = document.getElementById('canvasContainer');
            const canvas = document.createElement('canvas');
            canvas.id = `canvas-${filename}`;
            // make canva to be fixed in center of x and y
            canvas.style.position = 'fixed';
            canvas.style.top = '50%';
            canvas.style.left = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
            container.appendChild(canvas);
            return canvas;
        }
        function animatePixels(ctx) {
            let x = 0;
            let y = 0;
            const color = 'rgb(255,0,0)'; // Example color

            function draw() {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear the canvas
                renderPixelsToCanvas({ x, y, color }, ctx); // Draw the pixel
                x = (x + 1) % ctx.canvas.width; // Update x position
                y = (y + 1) % ctx.canvas.height; // Update y position
                requestAnimationFrame(draw); // Request the next frame
            }

            draw(); // Start the animation
        }

        // Call this function after setting up the canvas context
        animatePixels(ctx);

    </script>
</body>

</html>